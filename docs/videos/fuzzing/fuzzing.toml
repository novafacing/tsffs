# Copyright (C) 2023 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

secrets = ["USERNAME", "PASSWORD", "GH_TOKEN"]
secrets_file = "secrets.toml"
wpm = 130
keep_open = true

[kitty]
font_size = 28.0
allow_remote_control = "yes"

[[command]]
# Use for real demo:
# docker build -q -t demo-training-harnessing-tsffs --build-arg "USERNAME=$USERNAME" --build-arg "PASSWORD=$PASSWORD" --build-arg "GH_TOKEN=$GH_TOKEN" .
command = """
docker build -q -t demo-training-harnessing-tsffs --build-context "applications.security.fuzzing.confuse=../../../" --build-arg "USERNAME=$USERNAME" --build-arg "PASSWORD=$PASSWORD" --build-arg "GH_TOKEN=$GH_TOKEN" .
docker run --rm --name demo-training-harnessing-tsffs -it demo-training-harnessing-tsffs bash
apt-get -y update
apt-get -y install clang lld vim
cargo build --release --features=6.0.168
cargo run --release --bin simics-fuzz --features=6.0.168 -- \
  -c /tmp/hello-world-corpus/ -o /tmp/hello-world-solution/ -l ERROR -t -C 1 \
  --package 2096:6.0.69 \
  --file examples/hello-world/rsrc/HelloWorld.efi:%simics%/targets/hello-world/HelloWorld.efi \
  --file examples/hello-world/rsrc/app.py:%simics%/scripts/app.py \
  --file examples/hello-world/rsrc/app.yml:%simics%/scripts/app.yml \
  --file examples/hello-world/rsrc/minimal_boot_disk.craff:%simics%/targets/hello-world/minimal_boot_disk.craff \
  --file examples/hello-world/rsrc/run_uefi_app.nsh:%simics%/targets/hello-world/run_uefi_app.nsh \
  --file examples/hello-world/rsrc/run-uefi-app.simics:%simics%/targets/hello-world/run-uefi-app.simics \
  --command CONFIG:%simics%/scripts/app.yml
"""
prompt = true
immediate = true

[[command]]
script_pre = """
Welcome back to our series on TSFFS: Target software fuzzer for SIMICS.

In this video, I'll be walking through how to configure the fuzzer for a target and fuzz
the target using the TSFFS fuzzer. I'll assume you've completed the video tutorial on
harnessing and you have a built target.efi binary ready to go.

We'll be preparing our target application to be fuzzed for multiple fault conditions
including execution of interrupts, specifically invalid opcode and page fault
interrupts -- as well as the execution of off limits instructions and the access of
off-limits data. In a real application, you could apply the same techniques to detect
a triple fault in your bootloader, a write to off-limits device memory, or just about
anything else.

The first thing we need to do is install an additional tool called Rizin, a
full-featured reverse engineering tool. We'll only be using rizin to disassemble our
binary to determine where to place our instruction and memory breakpoints. In real
applications, you could use DWARF or PDB information for this purpose, but we'll stick
with disassembly for the sake of pulling back the curtain.

Installation instructions are available for all operating systems and linux
distributions at rizin.re.

"""
prompt = true
wpm = 250
command = """
echo 'deb http://download.opensuse.org/repositories/home:/RizinOrg/xUbuntu_22.04/ /' | tee /etc/apt/sources.list.d/home:RizinOrg.list
curl -fsSL https://download.opensuse.org/repositories/home:RizinOrg/xUbuntu_22.04/Release.key | gpg --dearmor | tee /etc/apt/trusted.gpg.d/home_RizinOrg.gpg > /dev/null
apt -y update
apt -y install rizin
"""

[[command]]
script_pre = """
Next, we'll change directories into our example directory from our repository.
"""
command = "cd docs/videos/fuzzing/\n"
prompt = true

[[command]]
script_pre = """
Let's take a look at our basic SIMICS script. This script is a simplified version of the
one distributed with the Quick Start Platform and will just initialize the platform and
download our EFI application to its simulated hard disk.

First, we run the provided script to boot from the hard drive. Next, we declare a
script-branch that enters the key combination when the BIOS menu appears to enter the
UEFI shell. From the shell, we run the built-in agent UEFI application to download our
target UEFI application to the system
"""
command = "vim rsrc/boot.simics\n"
prompt = true

[[command]]
script_pre = """
Let's close our SIMICS script and disassemble our UEFI application to extract some
important information.
"""
command = ":x\n"
prompt = true

[[command]]
script_pre = """
First, we want to know the address of the first 'cpuid' instruction in the UEFI
entrypoint function. This 'cpuid' is the magic instruction in our HARNESS_START
macro and indicates the point where our fuzzing loop will begin.

In our SIMICS script for fuzzing, we'll wait for this same magic instruction to match
the instruction pointer to the code address in our binary.

Note that for all of the rizin commands I'll use, I'm setting assembly variables false
and assembly lines to false. This just cleans up the output nicely.

Using rizin, we'll seek to the function entry0, which is the automatic name rizin gives
to the entrypoint, with the 'sf' command and print disassembly of the function with the
'pdf' command. We'll grep the output of the disassembly with the tilde command for
the 'cpuid' instruction, and we'll make a note of the first address we see because
the second address is the stop harness.
"""
command = "rizin -Aqqc 'e asm.var=false; e asm.lines=false; sf entry0; pdf ~cpuid;' rsrc/target.efi\n"
prompt = true

[[command]]
script_pre = """
Next, we want to find the address of the instruction in the branch when the first input
character is 'c' that calls the print function with the "Uh oh!" string.

Using rizin, we'll seek again to entry0 and this time grep for that string and make a note
of the address it occurs at."""
command = "rizin -Aqqc 'e asm.var=false; e asm.lines=false; sf entry0; pdf ~Uh oh!' rsrc/target.efi\n"
prompt = true

[[command]]
script_pre = """
This instruction is loading the address of the string into a register, so we need to
disassemble a few instructions forward to find the actual call. We'll use the 'pd' or print
disassembly command starting from the last instruction address.
"""
command = "rizin -Aqqc 'e asm.var=false; e asm.lines=false; sf entry0; pd 3 @ 0x180001255' rsrc/target.efi\n"
prompt = true

[[command]]
script_pre = """
Finally, we want to find the address in the data section where our off-limits data
lives. We can use the same strategy as before and search for the 'X' character we know
is being written to that data using the same command as before.
"""
command = """rizin -Aqqc "e asm.var=false; e asm.lines=false; sf entry0; pdf ~'X'" rsrc/target.efi\n"""
prompt = true

[[command]]
script_pre = """
This time, instead of needing to disassemble forward, we actually need to disassemble
backward to find out where the value of the rax register which holds the pointer to our
off limits data comes from. We'll use a similar instruction, but we'll print the last
three instructions this time.
"""
command = "rizin -Aqqc 'e asm.var=false; e asm.lines=false; sf entry0; pd -3 @ 0x180001298' rsrc/target.efi\n"
prompt = true

[[command]]
script_pre = """
We'll make a copy of our SIMICS boot script as fuzz.simics and we'll open it up to add
the configuration of our fuzzer.
"""
command = "cp rsrc/boot.simics rsrc/fuzz.simics\nvim rsrc/fuzz.simics\n"
prompt = true

[[command]]
script_pre = """
First, we'll go ahead and configure our fuzzer. The SIMICS module for the fuzzer, called
tsffs_module, is loaded for you. The module declares an interface which
has several functions that you can call either from a SIMICS script or from Python.

We'll use the '@' syntax in our SIMICS script and write Python code to configure the
fuzzer.

First, we need to call the 'init' method which does initialization of the module.

Next, we need to call 'add_processor' and pass the CPU core we are running on so that
event listeners and processor tracing can be configured.

After that, we'll add two faults to the configuration. This tells the fuzzer to treat
these faults (in this case page faults and invalid opcode faults), if they're observed,
as solutions. The inputs that trigger solutions will be stored and you can use the
fuzzer to investigate the root cause and disposition the issue, which we'll cover in the
next video.

We'll also call the 'set_breakpoints_are_faults' method, which tells the fuzzer to treat
any breakpoints that trigger during execution as solutions. By default, breakpoints are
not treated as solutions.

Finally, we'll type in our UEFI application on the console along with a newline, and
continue the simulation.
"""
command = ''':40
o    stop
    @conf.tsffs_module.iface.tsffs_module.init()
    @conf.tsffs_module.iface.tsffs_module.add_processor(SIM_get_object(simenv.system).mb.cpu0.core[0][0])
    @conf.tsffs_module.iface.tsffs_module.add_fault(14)
    @conf.tsffs_module.iface.tsffs_module.add_fault(6)
    @conf.tsffs_module.iface.tsffs_module.set_breakpoints_are_faults(True)
    $con.input "target.efi\\n"
    continue\e
'''
prompt = true

[[command]]
script_pre = """
Next, we'll add a script branch that will set up our breakpoints. The script branch will
set the variables we just found values for: our start harness address, the instruction
before the "Uh oh!" printout, and the off limits buffer.

Then, we'll set a breakpoint to wait for our magic start value. The magic start values
are defined and can be found in the header file, the start value is '1'.

We'll create a context and set the context of our CPU core to the one we just created.

Then, we'll get the value of the RIP register, which is our current instruction pointer
when the magic breakpoint executes. We'll calculate the offset between the actual
instruction pointer and the harness address in our binary.

Then we'll set the breakpoint on our bad instruction by calculating the real address
of the instruction we want to treat as "bad". Then we'll set a breakpoint using our
context with the '-x' flag, which means we'll break when that address is executed.

Finally, we'll set the breakpoint on our off limits data using our context with the
'-r' and '-w' flag, and we'll set it with a size of 0x100, so that any write to the whole
data array is caught.
"""
command = '''jjjoscript-branch "Set breakpoints" {
    local $TARGET_HARNESS_ADDRESS = 0x180001077
    local $TARGET_INSTRUCTION_ADDRESS = 0x18000125c
    local $TARGET_DATA_ADDRESS = 0x180003000

    local $MAGIC_START = 1
    bp.magic.wait-for $MAGIC_START

    local $ctx = (new-context)
    board.mb.cpu0.core[0][0].set-context $ctx

    local $rip = (board.mb.cpu0.core[0][0].read-reg rip)
    local $offset = $rip - $TARGET_HARNESS_ADDRESS

    local $harness_break_addr = ($TARGET_INSTRUCTION_ADDRESS + $offset)
    $ctx.break -x $harness_break_addr

    local $data_break_addr = ($TARGET_DATA_ADDRESS + $offset)
    $ctx.break -r -w $data_break_addr 0x100
}
\e
'''
prompt = true

[[command]]
script_pre = """
That's a fairly signficant amount of code, but hopefully it all makes sense! 

We'll go ahead and close that file.
"""
command = ":x\n"
prompt = true

[[command]]
script_pre = """
Now that we have our configuration in our script, we can run the fuzzer. We'll run the
fuzzer with 'cargo run', passing the manifest path to our root cargo.toml file. We
pass the feature for the version of SIMICS we have installed, and we compile in release
mode, and we run the simics-fuzz binary.

We'll set our log level to INFO and pass the package 2096 also known as x86 quick start
platform with version 6.0.69.

We also pass three files, which will be copied into the auto-created SIMICS project:

- The UEFI application
- The fuzz script
- The boot disk

And finally, we set the command we run to the run-script command with the fuzz script we
are copying into our project.
"""
command = """cargo run --manifest-path ../../../Cargo.toml --release --bin simics-fuzz --features=6.0.168 -- -l INFO --package 2096:6.0.69 --file rsrc/target.efi:%simics%/target.efi --file rsrc/fuzz.simics:%simics%/fuzz.simics --file rsrc/minimal_boot_disk.craff:%simics%/minimal_boot_disk.craff --command 'COMMAND:run-script "%simics%/fuzz.simics"'\n"""
prompt = true
script_post = """
If we let this run for a few minutes, we'll see the number of coverage, corpus, and
eventually objectives go up. We'll save these objectives/solutions (which will be output to our
solutions directory) for the next video, where we'll use repro mode to root cause our
faults.
"""
