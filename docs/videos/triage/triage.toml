# Copyright (C) 2023 Intel Corporation
# SPDX-License-Identifier: Apache-2.0

secrets = ["USERNAME", "PASSWORD", "GH_TOKEN"]
secrets_file = "secrets.toml"
wpm = 130
keep_open = true

[kitty]
font_size = 28.0
allow_remote_control = "yes"

[[command]]
# Use for real demo:
# docker build -q -t demo-training-harnessing-tsffs --build-arg "USERNAME=$USERNAME" --build-arg "PASSWORD=$PASSWORD" --build-arg "GH_TOKEN=$GH_TOKEN" .
command = """
docker build -q -t demo-training-harnessing-tsffs --build-context "applications.security.fuzzing.confuse=../../../" --build-arg "USERNAME=$USERNAME" --build-arg "PASSWORD=$PASSWORD" --build-arg "GH_TOKEN=$GH_TOKEN" .
docker run --rm --name demo-training-harnessing-tsffs -it demo-training-harnessing-tsffs bash
apt-get -y update
apt-get -y install clang lld vim
clear
"""
prompt = true
immediate = true

[[command]]
command = "clear\ncargo build --release --features=6.0.168\nclear\n"
prompt = true
immediate = true

[[command]]
script_pre = """
Welcome back to our series on TSFFS: Target software fuzzer for SIMICS.

In this video, I'll be walking through how to triage and disposition potential issues
found by a fuzzing session while using TSFFS.

The fuzzer takes full advantage of SIMICS' amazingly powerful debugging capabilities,
from full system and hardware introspection to time travel debugging with forward and
backward execution. Because SIMICS is so powerful, our triage mode is very lightweight
and works by dropping you into a SIMICS command line session at the point where the
fuzzer found the objective.
"""
prompt = true
command = "cd docs/videos/triage/\n"

[[command]]
script_pre = """
From here, we will reuse the exact command we ran to start the fuzzer in our last video,
but this time we will append the --repro flag, with a path to whichever solution we
want to examine in more detail.
"""
prompt = true
command = """cargo run --manifest-path ../../../Cargo.toml --release --bin simics-fuzz --features=6.0.168 -- -l INFO --package 2096:6.0.69 --file rsrc/target.efi:%simics%/target.efi --file rsrc/fuzz.simics:%simics%/fuzz.simics --file rsrc/minimal_boot_disk.craff:%simics%/minimal_boot_disk.craff --command 'COMMAND:run-script "%simics%/fuzz.simics"' --repro solutions/0840d4fd275a1727\n"""

[[command]]
script_pre = """
Once we drop into the SIMICS command line, we can gather any information we normally
would when debugging with SIMICS. First, we may want to examine the register state with
the print registers, or 'pregs' command.
"""
prompt = true
command = "pregs\n"

[[command]]
script_pre = """
We may also want to examine memory at a particular location, for example at the
instruction pointer, by using the examine, or 'x', command.
"""
prompt = true
command = "x %rip\n"

[[command]]
script_pre = """
In general, there are no limitations beyond SIMICS' own on what you can do. One
particularly helpful feature of our triage mode is the fuzzer automatically captures
a bookmark immediately after the start harness.

To view bookmarks, we can use the 'list-bookmark' command, and we can restore the
state of the fuzzer to the start harness by using the 'reverse-to' command with an
argument 'start', the name of the bookmark to reverse to.
"""
prompt = true
command = "reverse-to start\npregs\n"
